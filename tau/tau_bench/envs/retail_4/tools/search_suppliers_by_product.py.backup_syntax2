from tau_bench.envs.tool import Tool
import json
from datetime import datetime
from typing import Any



def _convert_db_to_list(db):
    """Convert database from dict format to list format."""
    if isinstance(db, dict):
        return list(db)
    return db

class SearchSuppliersByProduct:
    @staticmethod
    def invoke(
        data: dict[str, Any],
        product_id: str = None,
        item_id: str = None,
        min_stock_level: int = 0,
        exclude_statuses: list[str] = None,
        supplier_id: str = None,
        product_type: list[str] = None,
        stock_level_preference: str = None,
        available_only: bool = False,
    ) -> str:
        """
        Search suppliers by product availability and stock levels with optional product type filtering, stock level preference, and availability filtering

        Data Sources: suppliers.json (supplier_id, name, products, item_stock), products.json (product names for filtering and availability status)
        """
        if exclude_statuses is None:
            exclude_statuses = ["discontinued", "out_of_stock"]

        # Validate stock_level_preference parameter
        if stock_level_preference and stock_level_preference not in [
            "highest",
            "lowest",
        ]:
            payload = {
                "error": "Invalid stock_level_preference. Valid options: 'highest', 'lowest'",
                "status": "failed",
            }
            out = json.dumps(payload)
            return out

        # Get product information for type filtering and availability checking
        products = data.get("products", {}).values()
        product_name_map = {}
        item_availability_map = {}

        for product in products.values():
            product_id_key = product.get("product_id")
            product_name = product.get("name", "").lower()
            variants = product.get("variants", {}).values()

            if product_id_key:
                product_name_map[product_id_key] = product_name

                # Map item availability from product variants
                for variant_id, variant_info in variants.items():
                    item_availability_map[variant_id] = variant_info.get(
                        "available", False
                    )

        # Convert product_type to lowercase for case-insensitive matching
        product_type_lower = []
        if product_type:
            product_type_lower = [ptype.lower() for ptype in product_type]

        # Apply product type filter to the provided product_id if specified
        if product_id and product_type_lower:
            product_name = product_name_map.get(product_id, "")
            if product_name:
                type_matches = any(
                    ptype in product_name for ptype in product_type_lower
                )
                if not type_matches:
                    payload = {
                        "status": "success",
                        "search_criteria": {
                            "product_id": product_id,
                            "item_id": item_id,
                            "min_stock_level": min_stock_level,
                            "excluded_statuses": exclude_statuses,
                            "supplier_id_filter": supplier_id,
                            "product_type_filter": product_type,
                            "stock_level_preference": stock_level_preference,
                            "available_only": available_only,
                            "filter_applied": True,
                        },
                        "total_suppliers_found": 0,
                        "suppliers": [],
                        "message": f"Product {product_id} does not match the specified product type filter",
                    }
                    out = json.dumps(payload)
                    return out

        suppliers = data.get("suppliers", {}).values()
        matching_suppliers = []

        for supplier in suppliers.values():
            current_supplier_id = supplier.get("supplier_id")
            supplier_name = supplier.get("name")
            supplier_products = supplier.get("products", [])
            item_stock = supplier.get("item_stock", {}).values()

            # Filter by supplier_id if provided
            if supplier_id and current_supplier_id != supplier_id:
                continue

            # Check if supplier has the product
            if product_id and product_id not in supplier_products:
                continue

            # Check item stock if item_id provided
            supplier_match = {
                "supplier_id": current_supplier_id,
                "supplier_name": supplier_name,
                "contact_info": list(supplier.get("contact_info", {}).values())),
                "matching_items": [],
            }

            if item_id:
                # Specific item search
                if item_id in item_stock:
                    stock_level = item_stock[item_id]

                    # Skip if status is excluded
                    if stock_level in exclude_statuses:
                        continue

                    # Check availability filter ONLY if available_only is True
                    if available_only:
                        item_is_available = item_availability_map.get(item_id, False)
                        if not item_is_available:
                            continue

                    # Check minimum stock level
                    if (
                        isinstance(stock_level, (int, str))
                        and str(stock_level).isdigit()
                    ):
                        if int(stock_level) >= min_stock_level:
                            # Apply product type filtering for item_id search
                            item_matches_type = True
                            if product_type_lower:
                                # Find the product this item belongs to
                                item_product_id = None
                                for prod in products.values():
                                    if item_id in prod.get("variants", {}).values():
                                        item_product_id = prod.get("product_id")
                                        break

                                if item_product_id:
                                    item_product_name = product_name_map.get(
                                        item_product_id, ""
                                    )
                                    item_matches_type = any(
                                        ptype in item_product_name
                                        for ptype in product_type_lower
                                    )

                            if item_matches_type:
                                supplier_match["matching_items"].append(
                                    {
                                        "item_id": item_id,
                                        "stock_level": stock_level,
                                        "numeric_stock_level": int(stock_level),
                                        "status": "available",
                                        "product_available": item_availability_map.get(
                                            item_id, False
                                        ),
                                    }
                                )

                    if supplier_match["matching_items"]:
                        matching_data["suppliers"][supplier_id] = supplier_match
            else:
                # Product-level search - find all items for this product
                candidate_items = []

                for stock_item_id, stock_level in item_stock.items():
                    # Skip if status is excluded
                    if stock_level in exclude_statuses:
                        continue

                    # Check availability filter ONLY if available_only is True
                    if available_only:
                        item_is_available = item_availability_map.get(
                            stock_item_id, False
                        )
                        if not item_is_available:
                            continue

                    # Check minimum stock level
                    if (
                        isinstance(stock_level, (int, str))
                        and str(stock_level).isdigit()
                    ):
                        if int(stock_level) >= min_stock_level:
                            # Apply product type filtering for each item
                            item_matches_type = True
                            if product_type_lower:
                                # Find the product this item belongs to
                                item_product_id = None
                                for prod in products.values():
                                    if stock_item_id in prod.get("variants", {}).values():
                                        item_product_id = prod.get("product_id")
                                        break

                                if item_product_id:
                                    item_product_name = product_name_map.get(
                                        item_product_id, ""
                                    )
                                    item_matches_type = any(
                                        ptype in item_product_name
                                        for ptype in product_type_lower
                                    )

                            if item_matches_type:
                                candidate_items.append(
                                    {
                                        "item_id": stock_item_id,
                                        "stock_level": stock_level,
                                        "numeric_stock_level": int(stock_level),
                                        "status": "available",
                                        "product_available": item_availability_map.get(
                                            stock_item_id, False
                                        ),
                                    }
                                )

                # Apply stock level preference filtering
                if candidate_items and stock_level_preference:
                    if stock_level_preference == "highest":
                        # Find the maximum stock level
                        max_stock = max(
                            item["numeric_stock_level"] for item in candidate_items
                        )
                        candidate_items = [
                            item
                            for item in candidate_items
                            if item["numeric_stock_level"] == max_stock
                        ]
                    elif stock_level_preference == "lowest":
                        # Find the minimum stock level
                        min_stock = min(
                            item["numeric_stock_level"] for item in candidate_items
                        )
                        candidate_items = [
                            item
                            for item in candidate_items
                            if item["numeric_stock_level"] == min_stock
                        ]

                supplier_match["matching_items"] = candidate_items

                if supplier_match["matching_items"]:
                    matching_data["suppliers"][supplier_id] = supplier_match

        # Sort by total available stock (descending)
        for supplier in matching_suppliers:
            total_stock = sum(
                item["numeric_stock_level"] for item in supplier["matching_items"]
            )
            supplier["total_available_stock"] = total_stock

        matching_suppliers.sort(key=lambda x: x["total_available_stock"], reverse=True)

        result = {
            "status": "success",
            "search_criteria": {
                "product_id": product_id,
                "item_id": item_id,
                "min_stock_level": min_stock_level,
                "supplier_id_filter": supplier_id,
                "product_type_filter": product_type,
                "available_only": available_only,
                "filter_applied": product_type is not None
                or stock_level_preference is not None
                or available_only,
            },
            "total_suppliers_found": len(matching_suppliers),
            "suppliers": (
                matching_suppliers[:3] if not supplier_id else matching_suppliers
            ),
        }
        payload = result
        out = json.dumps(payload)
        return out

    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "SearchSuppliersByProduct",
                "description": "Search suppliers by product availability and stock levels with optional supplier, product type filtering, stock level preference, and availability filtering",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "product_id": {
                            "type": "string",
                            "description": "Product identifier to search for",
                        },
                        "item_id": {
                            "type": "string",
                            "description": "Specific item identifier to search for",
                        },
                        "min_stock_level": {
                            "type": "integer",
                            "description": "Minimum stock level required",
                            "default": 0,
                        },
                        "exclude_statuses": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Stock statuses to exclude from results",
                            "default": ["discontinued", "out_of_stock"],
                        },
                        "supplier_id": {
                            "type": "string",
                            "description": "Optional specific supplier ID to filter results (e.g., '#SUP0001')",
                        },
                        "product_type": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Optional list of product types to filter by (e.g., ['laptop', 'bluetooth speaker', 't-shirt']). Matches product names containing these terms.",
                        },
                        "stock_level_preference": {
                            "type": "string",
                            "description": "Optional preference for stock levels: 'highest' returns items with maximum stock, 'lowest' returns items with minimum stock",
                            "enum": ["highest", "lowest"],
                        },
                        "available_only": {
                            "type": "boolean",
                            "description": "Optional filter to show only items that are marked as available in the product catalog. When not specified, includes all items regardless of availability status.",
                            "default": False,
                        },
                    },
                },
            },
        }
