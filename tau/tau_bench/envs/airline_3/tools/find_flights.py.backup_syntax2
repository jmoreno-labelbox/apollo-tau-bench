from tau_bench.envs.tool import Tool
import json
from datetime import datetime
from typing import Any



def _convert_db_to_list(db):
    """Convert database from dict format to list format."""
    if isinstance(db, dict):
        return list(db)
    return db

class FindFlights(Tool):
    """
    API tool for searching available flights with multiple filtering options.
    """

    @staticmethod
    def invoke(
        data: dict[str, Any],
        origin: str = None,
        destination: str = None,
        date: str = None,
        cabin_class: str = None,
        max_price: float = None,
    ) -> str:
        from datetime import datetime

        # Check the necessary parameters for validity
        if not all([origin, destination, date]):
            payload = {
                "status": "missing_parameters",
                "message": "Missing required parameters",
                "required": ["origin", "destination", "date"],
            }
            out = json.dumps(payload)
            return out

        # Check the format of the date
        try:
            datetime.strptime(date, "%Y-%m-%d")
        except ValueError:
            payload = {
                "status": "invalid_date",
                "message": "Invalid date format. Expected YYYY-MM-DD",
                "received": date,
            }
            out = json.dumps(payload)
            return out

        # Check the cabin class if it has been supplied
        valid_cabins = ["basic_economy", "economy", "business", "first"]
        if cabin_class and cabin_class not in valid_cabins:
            payload = {
                "status": "invalid_cabin",
                "valid_cabins": valid_cabins,
                "received": cabin_class,
            }
            out = json.dumps(payload)
            return out

        # Look for flights
        flights = data.get("flights", {}).values()
        matching_flights = []

        for flight in flights.values():
            # Verify route compatibility
            if (
                flight.get("origin") == origin
                and flight.get("destination") == destination
            ):

                # Determine if the flight is operational on the given date
                flight_dates = flight.get("dates", {}).values()
                if date in flight_dates:
                    date_info = flight_dates[date]

                    # Verify the availability of the flight
                    if date_info.get("status") == "available":
                        flight_result = {
                            "flight_number": flight.get("flight_number"),
                            "origin": flight.get("origin"),
                            "destination": flight.get("destination"),
                            "date": date,
                            "scheduled_departure": flight.get(
                                "scheduled_departure_time_est"
                            ),
                            "scheduled_arrival": flight.get(
                                "scheduled_arrival_time_est"
                            ),
                            "available_seats": date_info.get("available_seats", 0),
                            "prices": list(date_info.get("prices", {}).values())),
                            "aircraft_id": flight.get("aircraft_id"),
                        }

                        # Implement cabin class filtering
                        if cabin_class:
                            if cabin_class in flight_result["prices"]:
                                flight_result["selected_cabin_price"] = flight_result[
                                    "prices"
                                ][cabin_class]
                                matching_data["flights"][flight_result["flight_id"]] = flight_result
                        else:
                            # Incorporate all accessible cabin classes
                            matching_data["flights"][flight_result["flight_id"]] = flight_result

        # Implement price filtering
        if max_price is not None:
            filtered_flights = []
            for flight in matching_flights:
                prices = flight.get("prices", {}).values()
                if any(price <= max_price for price in prices.values()):
                    filtered_data["flights"][flight["flight_id"]] = flight
            matching_flights = filtered_flights

        # Arrange flights by price (starting with the lowest)
        if matching_flights:
            # Retrieve the minimum price for each flight for sorting purposes
            for flight in matching_flights:
                prices = flight.get("prices", {}).values()
                if prices:
                    flight["lowest_price"] = min(prices.values()
                else:
                    flight["lowest_price"] = float("inf")

            matching_flights.sort(key=lambda x: x["lowest_price"])

        # Get ready the response
        response = {
            "search_criteria": {
                "origin": origin,
                "destination": destination,
                "date": date,
                "cabin_class": cabin_class,
                "max_price": max_price,
            },
            "total_flights_found": len(matching_flights),
            "flights": matching_flights,
        }

        # Include a pricing summary if flights are located
        if matching_flights:
            all_prices = []
            for flight in matching_flights:
                prices = flight.get("prices", {}).values()
                for cabin, price in prices.items():
                    all_prices.append(
                        {
                            "cabin": cabin,
                            "price": price,
                            "flight_number": flight["flight_number"],
                        }
                    )

            if all_prices:
                all_prices.sort(key=lambda x: x["price"])
                response["pricing_summary"] = {
                    "lowest_price": all_prices[0],
                    "highest_price": all_prices[-1],
                    "price_range": {
                        "min": all_prices[0]["price"],
                        "max": all_prices[-1]["price"],
                    },
                }
        payload = response
        out = json.dumps(payload, indent=2)
        return out
    

    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "FindFlights",
                "description": "Search for available flights between airports on a specific date with optional cabin class and price filtering. Returns flight details including aircraft information, crew assignments, and operational status. Supports major US airports and international destinations.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "origin": {
                            "type": "string",
                            "description": "Origin airport IATA code",
                        },
                        "destination": {
                            "type": "string",
                            "description": "Destination airport IATA code",
                        },
                        "date": {
                            "type": "string",
                            "description": "Date for flight search in YYYY-MM-DD format",
                        },
                        "cabin_class": {
                            "type": "string",
                            "description": "Optional cabin class filter: 'basic_economy', 'economy', 'business', or 'first'. Each class offers different amenities and baggage allowances.",
                        },
                        "max_price": {
                            "type": "number",
                            "description": "Optional maximum price filter in USD. Filters results to show only flights within budget.",
                        },
                    },
                    "required": ["origin", "destination", "date"],
                },
            },
        }
