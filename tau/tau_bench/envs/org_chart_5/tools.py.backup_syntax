import json
from collections import Counter
from typing import Any

from tau_bench.envs.tool import Tool




def _convert_db_to_list(db):
    """Convert database from dict format to list format."""
    if isinstance(db, dict):
        return list(db)
    return db


#Assistance function
def find_employee(employees: list[dict[str, Any]], employee_id: str) -> dict[str, Any]:
    """Assistance in locating an individual employee by their ID."""
    pass
    for e in employees:
        if e.get("employee_id") == employee_id:
            return e
    return None


class get_employee_profile(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        profile = employee.copy()
        profile["compensation_history"] = [
            c
            for c in data.get("compensation_records", {}).values()
            if c.get("employee_id") == employee_id
        ]
        profile["performance_reviews"] = [
            r
            for r in data.get("performance_reviews", {}).values()
            if r.get("employee_id") == employee_id
        ]
        profile["leave_records"] = [
            l
            for l in data.get("leave_records", {}).values()
            if l.get("employee_id") == employee_id
        ]
        for doc_record in data.get("employee_documents", {}).values().get(
            "employee_documents", []
        ):
            if doc_record.get("employee_id") == employee_id:
                profile["documents"] = doc_record.get("documents", [])
                break
        payload = profile
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetEmployeeProfile",
                "description": "Retrieve a comprehensive profile for an employee, including job, compensation, reviews, and documents.",
                "parameters": {
                    "type": "object",
                    "properties": {"employee_id": {"type": "string"}},
                    "required": ["employee_id"],
                },
            },
        }


class create_employee_from_offer_letter(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], offer_doc_id: str = None, employee_id: str = None) -> str:
        if not offer_doc_id or not employee_id:
            payload = {"error": "offer_doc_id and employee_id are required"}
            out = json.dumps(
                payload, indent=2
            )
            return out
        if find_employee(data.get("employees", {}).values(), employee_id):
            payload = {"error": f"employee_id {employee_id} already exists"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        new_employee = {
            "employee_id": employee_id,
            "first_name": "New",
            "last_name": "Hire",
            "status": "Active",
            "notes": f"Created from offer doc {offer_doc_id}",
        }
        data["employees"][new_employee["employee_id"]] = new_employee
        payload = {
                "success": f"Employee {employee_id} created from offer letter {offer_doc_id}"
            }
        out = json.dumps(
            payload, indent=2,
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "createEmployeeFromOfferLetter",
                "description": "Creates a new employee record based on an offer letter.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "offer_doc_id": {"type": "string"},
                        "employee_id": {"type": "string"},
                    },
                    "required": ["offer_doc_id", "employee_id"],
                },
            },
        }


class list_department_headcount(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], department_id: str = None) -> str:
        headcount = len(
            [
                e
                for e in data.get("employees", {}).values()
                if e.get("department_id") == department_id
                and e.get("status") == "Active"
            ]
        )
        payload = {"department_id": department_id, "active_headcount": headcount}
        out = json.dumps(
            payload, indent=2
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "ListDepartmentHeadcount",
                "description": "Return current headcount of active employees for a department.",
                "parameters": {
                    "type": "object",
                    "properties": {"department_id": {"type": "string"}},
                    "required": ["department_id"],
                },
            },
        }


class update_employee_compensation(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, new_comp: dict = None) -> str:
        if not find_employee(data.get("employees", {}).values(), employee_id):
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        new_comp_record = new_comp.copy()
        new_comp_record["employee_id"] = employee_id
        if "compensation_id" not in new_comp_record:
            payload = {"error": "new_comp payload must include a unique compensation_id"}
            out = json.dumps(
                payload, indent=2,
            )
            return out

        data["compensation_records"][new_comp_record["compensation_record_id"]] = new_comp_record
        payload = {
                "success": f"Compensation record {new_comp_record['compensation_id']} added for {employee_id}"
            }
        out = json.dumps(
            payload, indent=2,
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "UpdateEmployeeCompensation",
                "description": "Adds a new compensation record for an employee, preserving history.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "new_comp": {
                            "type": "object",
                            "description": "New compensation details including a unique compensation_id",
                        },
                    },
                    "required": ["employee_id", "new_comp"],
                },
            },
        }


class get_performance_review_status(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], department_id: str = None, employee_id: str = None) -> str:
        reviews = data.get("performance_reviews", {}).values()

        if employee_id:
            results = [r for r in reviews.values() if r.get("employee_id") == employee_id]
        elif department_id:
            dept_employees = {
                e["employee_id"]
                for e in data.get("employees", {}).values()
                if e.get("department_id") == department_id
            }
            results = [r for r in reviews.values() if r.get("employee_id") in dept_employees]
        else:
            payload = {"error": "Either employee_id or department_id is required"}
            out = json.dumps(
                payload, indent=2
            )
            return out
        payload = results
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetPerformanceReviewStatus",
                "description": "List performance reviews for a department or an individual employee.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "department_id": {"type": "string"},
                        "employee_id": {"type": "string"},
                    },
                },
            },
        }


class submit_performance_review(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, review_data: dict[str, Any] = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        new_review = review_data.copy()
        new_review["employee_id"] = employee_id
        if "review_id" not in new_review:
            new_review["review_id"] = (
                f"PR_NEW_{len(data.get('performance_reviews', {})) + 1}"
            )

        data["performance_reviews"][new_review["performance_review_id"]] = new_review

        if "performance_review_ids" not in employee:
            employee["performance_review_ids"] = []
        if new_review["review_id"] not in employee["performance_review_ids"]:
            employee["performance_review_ids"].append(new_review["review_id"])
        payload = {
                "success": f"Performance review {new_review['review_id']} submitted for {employee_id}"
            }
        out = json.dumps(
            payload, indent=2,
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "SubmitPerformanceReview",
                "description": "Submit a new performance review for an employee.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "review_data": {
                            "type": "object",
                            "description": "Details including review_id, type, rating, date",
                        },
                    },
                    "required": ["employee_id", "review_data"],
                },
            },
        }


class get_leave_calendar(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], department_id: str = None, employee_id: str = None, start_date: str = None, end_date: str = None) -> str:
        if not department_id and not employee_id:
            payload = {"error": "department_id or employee_id is required"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        results = data.get("leave_records", {}).values()

        if department_id:
            dept_employees = {
                e["employee_id"]
                for e in data.get("employees", {}).values()
                if e.get("department_id") == department_id
            }
            results = [r for r in results.values() if r.get("employee_id") in dept_employees]

        if employee_id:
            results = [r for r in results.values() if r.get("employee_id") == employee_id]

        if start_date:
            results = [r for r in results.values() if r.get("end_date", "") >= start_date]

        if end_date:
            results = [r for r in results.values() if r.get("start_date", "") <= end_date]
        payload = results
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetLeaveCalendar",
                "description": "Retrieve leave records for a department or employee, optionally within a date range.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "department_id": {"type": "string"},
                        "employee_id": {"type": "string"},
                        "start_date": {"type": "string", "description": "YYYY-MM-DD"},
                        "end_date": {"type": "string", "description": "YYYY-MM-DD"},
                    },
                },
            },
        }


class request_leave(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, leave_data: dict = None) -> str:
        if not find_employee(data.get("employees", {}).values(), employee_id):
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        new_leave = leave_data.copy()
        new_leave["employee_id"] = employee_id
        if "leave_id" not in new_leave:
            new_leave["leave_id"] = f"LV_NEW_{len(data.get("leave_records", {})) + 1}"

        data["leave_records"][new_leave["leave_record_id"]] = new_leave
        payload = {"success": f"Leave {new_leave['leave_id']} requested for {employee_id}"}
        out = json.dumps(
            payload, indent=2,
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "RequestLeave",
                "description": "Submit a new leave request for an employee.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "leave_data": {
                            "type": "object",
                            "description": "Details including a unique leave_id",
                        },
                    },
                    "required": ["employee_id", "leave_data"],
                },
            },
        }


class get_benefits_enrollment(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, department_id: str = None) -> str:
        if employee_id:
            employee = find_employee(data.get("employees", {}).values(), employee_id)
            if not employee:
                payload = {"error": f"employee_id {employee_id} not found"}
                out = json.dumps(
                    payload, indent=2
                )
                return out
            payload = employee.get("benefit_plan_ids", [])
            out = json.dumps(payload, indent=2)
            return out

        if department_id:
            dept_employees = [
                e
                for e in data.get("employees", {}).values()
                if e.get("department_id") == department_id
            ]
            all_benefits = {
                plan_id
                for emp in dept_employees
                for plan_id in emp.get("benefit_plan_ids", [])
            }
            payload = list(all_benefits)
            out = json.dumps(payload, indent=2)
            return out
        payload = {"error": "employee_id or department_id is required"}
        out = json.dumps(
            payload, indent=2
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetBenefitsEnrollment",
                "description": "List benefits enrollment status for an employee or department.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "department_id": {"type": "string"},
                    },
                },
            },
        }


class enroll_in_benefit(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, benefit_id: str = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        if "benefit_plan_ids" not in employee:
            employee["benefit_plan_ids"] = []

        if benefit_id not in employee["benefit_plan_ids"]:
            employee["benefit_plan_ids"].append(benefit_id)
            payload = {"success": f"Employee {employee_id} enrolled in benefit {benefit_id}"}
            out = json.dumps(
                payload, indent=2,
            )
            return out
        else:
            payload = {
                    "success": f"Employee {employee_id} was already enrolled in benefit {benefit_id}"
                }
            out = json.dumps(
                payload, indent=2,
            )
            return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "EnrollInBenefit",
                "description": "Enroll an employee IND a specific benefit plan (non-destructive).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "benefit_id": {"type": "string"},
                    },
                    "required": ["employee_id", "benefit_id"],
                },
            },
        }


class remove_from_benefit(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, benefit_id: str = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        if (
            "benefit_plan_ids" in employee
            and benefit_id in employee["benefit_plan_ids"]
        ):
            employee["benefit_plan_ids"].remove(benefit_id)
            payload = {
                    "success": f"Employee {employee_id} removed from benefit {benefit_id}"
                }
            out = json.dumps(
                payload, indent=2,
            )
            return out
        else:
            payload = {
                    "success": f"Employee {employee_id} was not enrolled in benefit {benefit_id}"
                }
            out = json.dumps(
                payload, indent=2,
            )
            return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "RemoveFromBenefit",
                "description": "Remove an employee from a specific benefit plan.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "benefit_id": {"type": "string"},
                    },
                    "required": ["employee_id", "benefit_id"],
                },
            },
        }


class get_document_compliance_status(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None) -> str:
        emp_doc_record = next(
            (
                d
                for d in data.get("employee_documents", {}).values().get(
                    "employee_documents", []
                )
                if d.get("employee_id") == employee_id
            ),
            None,
        )
        if not emp_doc_record:
            payload = {"employee_id": employee_id, "status": "No documents on file"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        docs = emp_doc_record.get("documents", [])
        doc_categories = {doc.get("category") for doc in docs}

        status = {
            "employee_id": employee_id,
            "has_nda": "NDA" in doc_categories,
            "has_id_verification": "ID Verification" in doc_categories,
            "document_count": len(docs),
        }
        payload = status
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetDocumentComplianceStatus",
                "description": "Check if an employee has key required documents like an NDA and ID verification.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "department_id": {"type": "string"},
                    },
                    "required": [],
                },
            },
        }


class upload_employee_document(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, document_data: dict = None) -> str:
        main_container = data.get("employee_documents", {}).values().get(
            "employee_documents", []
        )

        emp_doc_record = next(
            (
                d
                for d in data.get("employee_documents", {}).values().get(
                    "employee_documents", []
                )
                if d.get("employee_id") == employee_id
            ),
            None,
        )
        if not emp_doc_record:
            employee = find_employee(data.get("employees", {}).values(), employee_id)
            employee_name = (
                f"{employee.get('first_name')} {employee.get('last_name')}"
                if employee
                else "Unknown"
            )

            emp_doc_record = {
                "employee_id": employee_id,
                "name": employee_name,
                "documents": [],
            }
            data["employee_documents"][emp_doc_record["employee_document_id"]] = emp_doc_record

        emp_doc_record["documents"].append(document_data)
        payload = {"success": f"Document uploaded for {employee_id}"}
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "UploadEmployeeDocument",
                "description": "Upload or attach a new document to an employee's record.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "document_data": {
                            "type": "object",
                            "description": "Document metadata and content",
                        },
                    },
                    "required": ["employee_id", "document_data"],
                },
            },
        }


class get_org_diversity_metrics(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], department_id: str = None, level: str = None) -> str:
        employees_to_scan = data.get("employees", {}).values()
        if department_id:
            employees_to_scan = [
                e for e in employees_to_scan.values() if e.get("department_id") == department_id
            ]
        if level:
            employees_to_scan = [
                e for e in employees_to_scan.values() if e.get("level_id") == level
            ]

        gender_counts = Counter(e.get("gender") for e in employees_to_scan.values())
        ethnicity_counts = Counter(e.get("ethnicity_code") for e in employees_to_scan.values())

        metrics = {
            "filter_department": department_id,
            "filter_level": level,
            "total_employees_in_filter": len(employees_to_scan),
            "gender_distribution": dict(gender_counts),
            "ethnicity_distribution": dict(ethnicity_counts),
        }
        payload = metrics
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetOrgDiversityMetrics",
                "description": "Return diversity metrics (gender, ethnicity) by department, level, or company-wide.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "department_id": {"type": "string"},
                        "level": {"type": "string"},
                    },
                },
            },
        }


class update_employee_job_level(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, new_level: str = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        employee["level_id"] = new_level
        payload = {"success": f"Job level for {employee_id} updated to {new_level}"}
        out = json.dumps(
            payload, indent=2
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "UpdateEmployeeJobLevel",
                "description": "Change an employee's job level ID.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "new_level": {"type": "string"},
                    },
                    "required": ["employee_id", "new_level"],
                },
            },
        }


class get_open_positions(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], department_id: str = None, level: str = None) -> str:
        filled_position_ids = {
            e.get("position_id")
            for e in data.get("employees", {}).values()
            if e.get("status") == "Active"
        }
        all_positions = data.get("positions", {}).values()

        open_positions = [
            p for p in all_positions.values() if p.get("position_id") not in filled_position_ids
        ]

        if department_id:
            open_positions = [
                p for p in open_positions if p.get("department_id") == department_id
            ]
        if level:
            open_positions = [p for p in open_positions.values() if p.get("level_id") == level]
        payload = open_positions
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetOpenPositions",
                "description": "List all open positions not currently filled by an active employee.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "department_id": {"type": "string"},
                        "level": {"type": "string"},
                    },
                },
            },
        }


class close_position(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], position_id: str = None) -> str:
        positions = data.get("positions", {}).values()
        position_to_close = next(
            (p for p in positions.values() if p.get("position_id") == position_id), None
        )

        if position_to_close:
            positions.remove(position_to_close)
            payload = {"success": f"Position {position_id} has been closed and removed."}
            out = json.dumps(
                payload, indent=2,
            )
            return out
        else:
            payload = {"error": f"Position {position_id} not found."}
            out = json.dumps(payload, indent=2)
            return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "ClosePosition",
                "description": "Mark a position as closed by removing it from the list of available positions.",
                "parameters": {
                    "type": "object",
                    "properties": {"position_id": {"type": "string"}},
                    "required": ["position_id"],
                },
            },
        }


class update_company_document_content(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], doc_id: str = None, new_content: str = None) -> str:
        all_docs = data.get("company_doc", {}).values().get("company_documents", [])
        doc_to_update = next((d for d in all_docs.values() if d.get("id") == doc_id), None)

        if doc_to_update:
            doc_to_update["content"] = new_content
            doc_to_update["last_updated"] = "2025-06-24"
            payload = {"success": f"Content for document '{doc_id}' updated successfully."}
            out = json.dumps(
                payload, indent=2,
            )
            return out
        else:
            payload = {"error": f"Company document with ID '{doc_id}' not found."}
            out = json.dumps(
                payload, indent=2
            )
            return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "UpdateCompanyDocumentContent",
                "description": "Updates the full text content of an existing company-wide document.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "doc_id": {"type": "string"},
                        "new_content": {"type": "string"},
                    },
                    "required": ["doc_id", "new_content"],
                },
            },
        }


class get_compensation_records(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None) -> str:
        if not find_employee(data.get("employees", {}).values(), employee_id):
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        records = [
            c
            for c in data.get("compensation_records", {}).values()
            if c.get("employee_id") == employee_id
        ]
        payload = records
        out = json.dumps(payload, indent=2)
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "GetCompensationRecords",
                "description": "Retrieve all historical compensation records for an employee.",
                "parameters": {
                    "type": "object",
                    "properties": {"employee_id": {"type": "string"}},
                    "required": ["employee_id"],
                },
            },
        }


class update_employee_status(Tool):
    @staticmethod
    def invoke(data: dict[str, Any], employee_id: str = None, new_status: str = None) -> str:
        employee = find_employee(data.get("employees", {}).values(), employee_id)
        if not employee:
            payload = {"error": f"employee_id {employee_id} not found"}
            out = json.dumps(
                payload, indent=2
            )
            return out

        employee["status"] = new_status
        if new_status.lower() == "terminated":
            employee["termination_date"] = "2025-06-24"  # Utilizing our typical "today"
        payload = {"success": f"Employee {employee_id} status updated to {new_status}"}
        out = json.dumps(
            payload, indent=2,
        )
        return out
    @staticmethod
    def get_info() -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "UpdateEmployeeStatus",
                "description": "Update an employee's current status (e.g., 'Active', 'On Leave', 'Terminated').",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "employee_id": {"type": "string"},
                        "new_status": {"type": "string"},
                    },
                    "required": ["employee_id", "new_status"],
                },
            },
        }


TOOLS = [
    get_employee_profile(),
    create_employee_from_offer_letter(),
    list_department_headcount(),
    update_employee_compensation(),
    get_performance_review_status(),
    submit_performance_review(),
    get_leave_calendar(),
    request_leave(),
    get_benefits_enrollment(),
    enroll_in_benefit(),
    remove_from_benefit(),
    get_document_compliance_status(),
    upload_employee_document(),
    get_org_diversity_metrics(),
    update_employee_job_level(),
    get_open_positions(),
    close_position(),
    update_company_document_content(),
    get_compensation_records(),
    update_employee_status(),
]
