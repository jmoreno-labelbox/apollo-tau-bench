#!/usr/bin/env python3
"""
Script to automatically fix common syntax errors detected by vulture.

Uses the syntax_errors.json file generated by find_unused_code.py to fix:
- Missing closing parentheses
- Unmatched parentheses
- Missing closing parentheses before colons in for/if statements
- Incorrectly used .values() that should be list()
- F-string issues

Usage:
  python fix_syntax_errors.py                    # Fix errors (with backup)
  python fix_syntax_errors.py --dry-run          # Preview fixes without modifying
  python fix_syntax_errors.py --no-backup        # Fix without creating backups
"""

import argparse
import json
import re
import shutil
from pathlib import Path
from collections import defaultdict


def load_syntax_errors(json_file="syntax_errors.json"):
    """Load syntax errors from JSON file."""
    try:
        with open(json_file, 'r') as f:
            data = json.load(f)
        return data.get('all_errors', [])
    except FileNotFoundError:
        print(f"❌ Error: {json_file} not found. Run find_unused_code.py first.")
        return []
    except Exception as e:
        print(f"❌ Error loading {json_file}: {e}")
        return []


def fix_unclosed_parenthesis(line, error_msg):
    """
    Fix '(' was never closed errors.
    Common pattern: .values() at end of line missing closing paren
    """
    # Pattern: ends with .values() but missing closing paren
    if '.values()' in line and line.rstrip().endswith('.values()'):
        return line.rstrip() + ')\n'
    
    # Pattern: ends with other expression in comprehension
    if ' for ' in line and ' in ' in line:
        # Check if it's missing closing paren at end
        if not line.rstrip().endswith(')'):
            return line.rstrip() + ')\n'
    
    return None


def fix_unmatched_closing_paren(line, error_msg):
    """
    Fix unmatched ')' errors.
    Common pattern: `.values()), something` should be `.values(), something`
    """
    # Pattern: .values()), should be .values(),
    if '.values()),' in line:
        fixed = line.replace('.values()),', '.values(),')
        return fixed
    
    # Pattern: .values()): should be .values():
    if '.values())):' in line:
        fixed = line.replace('.values())):', '.values()):')
        return fixed
    
    # Pattern: extra ) before :
    if re.search(r'\)\):', line):
        fixed = re.sub(r'\)\):', '):', line)
        return fixed
    
    return None


def fix_missing_closing_paren_before_colon(line, error_msg):
    """
    Fix 'invalid syntax at "for i, x in enumerate(x.values():"'
    Missing closing parenthesis before colon.
    """
    # Pattern: enumerate(something.values(): should be enumerate(something.values()):
    if 'enumerate(' in line and '.values():' in line:
        fixed = line.replace('.values():', '.values()):')
        return fixed
    
    # Pattern: any(...values(): should be any(...values()):
    if 'any(' in line and '.values():' in line:
        fixed = line.replace('.values():', '.values()):')
        return fixed
    
    # Pattern: all(...values(): should be all(...values()):
    if 'all(' in line and '.values():' in line:
        fixed = line.replace('.values():', '.values()):')
        return fixed
    
    return None


def fix_mismatched_closing_bracket(line, error_msg):
    """
    Fix "closing parenthesis ')' does not match opening parenthesis '{'"
    Common pattern: .get("key", {}).values()) should be list(.get("key", {}).values())
    """
    # Pattern: something.get("key", {}).values()), in dict/list context
    if '.values()),' in line and '{' in line:
        # Check if it's in a dict-like structure
        if ':' in line and '"' in line:
            # Replace .values()) with .values())
            # This is tricky - often .values() shouldn't be called on a dict
            # Better to wrap in list()
            fixed = re.sub(r'(\w+\.get\([^)]+\{[^}]*\}\)\.values\(\))', r'list(\1)', line)
            return fixed
    
    # Pattern: closing } does not match (
    # Often from mismatched .values()
    if '.values()}' in line:
        fixed = line.replace('.values()}', '.values())')
        return fixed
    
    return None


def fix_fstring_unmatched_paren(line, error_msg):
    """
    Fix f-string: unmatched '(' errors.
    Common pattern: f"text{len(data.get("key", {})) + 1}" has inner quotes issue
    """
    # Pattern: f-string with nested data.get( that has quote issues
    if 'f"' in line and 'data.get(' in line:
        # Try to fix inner quotes: data.get("key") should use single quotes in f-string
        fixed = re.sub(r'data\.get\("([^"]+)"', r"data.get('\1'", line)
        fixed = re.sub(r'data\.get\("([^"]+)",\s*\{\}\)', r"data.get('\1', {})", fixed)
        return fixed
    
    return None


def fix_invalid_syntax_general(line, error_msg):
    """
    Fix general invalid syntax errors.
    """
    # Pattern: _convert_db_to_list(data.get("x", {}).values() - missing closing paren
    if '_convert_db_to_list(' in line and '.values()' in line and not '.values())' in line:
        if line.rstrip().endswith('.values()'):
            return line.rstrip() + ')\n'
    
    # Pattern: missing closing paren in comprehension
    if '(' in line and 'for ' in line and ' in ' in line:
        open_count = line.count('(')
        close_count = line.count(')')
        if open_count > close_count:
            return line.rstrip() + ')' * (open_count - close_count) + '\n'
    
    # Pattern: misplaced comma in string literal
    if '"' in line and ',' in line:
        # Check for pattern like: "key": value," that should be "key": value,
        if ',"' in line and error_msg and 'Perhaps you forgot a comma' in error_msg:
            # This is actually about the line BEFORE needing a comma
            return None  # Can't fix without context
    
    # Pattern: general missing closing parens
    if '(' in line:
        open_count = line.count('(')
        close_count = line.count(')')
        if open_count > close_count:
            # Check if line ends with something that should have closing paren
            if any(line.rstrip().endswith(pat) for pat in ['.values()', '(', 'for tag in tags)']):
                return line.rstrip() + ')' * (open_count - close_count) + '\n'
    
    return None


def apply_fix(filepath, line_num, error_msg, dry_run=False):
    """
    Apply fix to a specific line in a file.
    
    Returns: (success, original_line, fixed_line)
    """
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
    except Exception as e:
        return (False, None, f"Error reading file: {e}")
    
    if line_num < 1 or line_num > len(lines):
        return (False, None, "Line number out of range")
    
    line_idx = line_num - 1
    original_line = lines[line_idx]
    fixed_line = None
    
    # Try different fix strategies based on error message
    if "'(' was never closed" in error_msg:
        fixed_line = fix_unclosed_parenthesis(original_line, error_msg)
    elif "unmatched ')'" in error_msg:
        fixed_line = fix_unmatched_closing_paren(original_line, error_msg)
    elif "invalid syntax at \"for i," in error_msg or ".values():" in original_line:
        fixed_line = fix_missing_closing_paren_before_colon(original_line, error_msg)
    elif "closing parenthesis" in error_msg and "does not match" in error_msg:
        fixed_line = fix_mismatched_closing_bracket(original_line, error_msg)
    elif "f-string: unmatched" in error_msg:
        fixed_line = fix_fstring_unmatched_paren(original_line, error_msg)
    elif "invalid syntax" in error_msg:
        fixed_line = fix_invalid_syntax_general(original_line, error_msg)
    
    if fixed_line and fixed_line != original_line:
        if not dry_run:
            lines[line_idx] = fixed_line
            with open(filepath, 'w') as f:
                f.writelines(lines)
        return (True, original_line.rstrip(), fixed_line.rstrip())
    
    return (False, original_line.rstrip(), "No fix available")


def main():
    parser = argparse.ArgumentParser(
        description="Automatically fix syntax errors in Python files",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview fixes without modifying files'
    )
    
    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Do not create backup files (use with caution)'
    )
    
    parser.add_argument(
        '--input',
        type=str,
        default='syntax_errors.json',
        help='Input JSON file with syntax errors (default: syntax_errors.json)'
    )
    
    parser.add_argument(
        '--limit',
        type=int,
        help='Limit number of files to fix (for testing)'
    )
    
    args = parser.parse_args()
    
    print("🔧 Syntax Error Fixer")
    print("=" * 80)
    
    # Load syntax errors
    errors = load_syntax_errors(args.input)
    if not errors:
        print("No syntax errors found.")
        return 0
    
    print(f"Loaded {len(errors)} syntax error(s)")
    
    # Group errors by file
    errors_by_file = defaultdict(list)
    for error in errors:
        errors_by_file[error['filepath']].append(error)
    
    print(f"Errors in {len(errors_by_file)} file(s)\n")
    
    if args.dry_run:
        print("🧪 DRY RUN MODE - No files will be modified\n")
    
    # Process each file
    files_processed = 0
    files_fixed = 0
    total_fixes = 0
    total_skipped = 0
    
    for filepath in sorted(errors_by_file.keys()):
        if args.limit and files_processed >= args.limit:
            break
        
        file_errors = errors_by_file[filepath]
        files_processed += 1
        
        print(f"\n📄 {filepath}")
        print(f"   {len(file_errors)} error(s) to fix")
        
        # Create backup if requested
        if not args.dry_run and not args.no_backup:
            try:
                backup_path = f"{filepath}.backup_syntax"
                shutil.copy2(filepath, backup_path)
            except Exception as e:
                print(f"   ⚠️  Warning: Could not create backup: {e}")
        
        # Sort errors by line number (fix from bottom to top to preserve line numbers)
        file_errors_sorted = sorted(file_errors, key=lambda x: x['line'], reverse=True)
        
        file_fixes = 0
        for error in file_errors_sorted:
            success, original, result = apply_fix(
                filepath,
                error['line'],
                error['error'],
                dry_run=args.dry_run
            )
            
            if success:
                file_fixes += 1
                total_fixes += 1
                print(f"   ✅ Line {error['line']}: FIXED")
                print(f"      Before: {original}")
                print(f"      After:  {result}")
            else:
                total_skipped += 1
                if args.dry_run:
                    print(f"   ⚠️  Line {error['line']}: {result}")
                else:
                    print(f"   ❌ Line {error['line']}: Could not fix - {result}")
        
        if file_fixes > 0:
            files_fixed += 1
    
    # Summary
    print(f"\n{'=' * 80}")
    print("📊 SUMMARY")
    print(f"{'=' * 80}")
    print(f"Files processed:  {files_processed}")
    print(f"Files modified:   {files_fixed}")
    print(f"Errors fixed:     {total_fixes}")
    print(f"Errors skipped:   {total_skipped}")
    print(f"Success rate:     {(total_fixes / len(errors) * 100):.1f}%")
    
    if not args.dry_run and files_fixed > 0:
        if not args.no_backup:
            print(f"\n💾 Backup files created with .backup_syntax extension")
        print(f"\n✅ Fixes applied! Re-run find_unused_code.py to verify.")
    elif args.dry_run:
        print(f"\n🧪 Dry run complete. Use without --dry-run to apply fixes.")
    
    print(f"{'=' * 80}\n")
    
    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main())
